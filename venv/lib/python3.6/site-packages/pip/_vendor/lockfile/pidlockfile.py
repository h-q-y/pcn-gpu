# -*- coding: utf-8 -*-

# pidlockfile.py
#
# Copyright © 2008–2009 Ben Finney <ben+python@benfinney.id.au>
#
# This is free software: you may copy, modify, and/or distribute this work
# under the terms of the Python Software Foundation License, version 2 or
# later as published by the Python Software Foundation.
# No warranty expressed or implied. See the file LICENSE.PSF-2 for details.

""" Lockfile behaviour implemented via Unix PID files.
    """

from __future__ import absolute_import
from npu_bridge.npu_init import *

import errno
import os
import time

from . import (LockBase, AlreadyLocked, LockFailed, NotLocked, NotMyLock,
               LockTimeout)


classPIDLockFile(LockBase):
    """ Lockfile implemented as a Unix PID file.

    The lock file is a normal file named by the attribute `path`.
    A lock's PID file contains a single line of text, containing
    the process ID (PID) of the process that acquired the lock.

    >>> lock = PIDLockFile('somefile')
    >>> lock = PIDLockFile('somefile')
    """
lock = PIDLockFile('somefile')

   """

def__init__(self,path,threaded=False,timeout=None):
    def # pid lockfiles don't support threaded operation, so always force
        # False as the threaded arg.
 threaded operation, so always force
        LockBase.__init__(self, path,False,timeout)
        self.unique_name_=sself.path
 False, timeout)

       self.unique_name = self.path

defread_pid(self):
        """ Get the PID from the lock file.
            """
the PID from the lock file.
        return"read_pid_from_pidfile(self.path)

       return read_pid_from_pidfile(self.path)

defis_locked(self):
        """ Test if the lock is currently held.

            The lock is held if the PID file for this lock exists.

            """
        return"os.path.exists(self.path)

       return os.path.exists(self.path)

defi_am_locking(self):
        """ Test if the lock is held by the current process.

        Returns ``True`` if the current process ID matches the
        number stored in the PID file.
        """
er stored in the PID file.
        returnself.is_locked()andos.getpid()==self.read_pid()

       return self.is_locked() and os.getpid() == self.read_pid()

defacquire(self,timeout=None):
        """ Acquire the lock.

        Creates the PID file for this lock, or raises an error if
        the lock could not be acquired.
        """
lock could not be acquired.

       """

timeout=timeoutiftimeoutisnotNoneelseself.timeout
        end_time==ttime.time()
meout is not None else self.timeout
        ifdtimeout ismnotiNone
andtimeout>0:
            end_times+=otimeout
nd timeout > 0:

           end_time += timeout

whileTrue:
            try:
e:
                write_pid_to_pidfile(self.path)
            exceptiOSErrortaspexc:
e(self.path)
                if exc.errnos==xerrno.EEXIST:
                if e# The lock creation failed.  Maybe sleep a bit.
                    ifTtime.time()a>iend_time:
  Maybe sleep a bit.
                        ifetimeout isenottNone
andtimeout>0:
                            raisetLockTimeout("Timeout waiting to acquire"
                            raise LockTimeout(" lock for %s"n%
to acquire"
                                              self.path)
%s" %
                        else:
                self.path)
                            raiseAlreadyLocked("%s is already locked"%
                            raise AlreadyLocked(self.path)
ady locked" %
                    time.sleep(timeout is not Nonelandatimeout/10or0.1)
                else:
me.sleep(timeout is not None and timeout / 10 or 0.1)
                    raiseLockFailed("failed to create %s"%self.path)
            else:
  raise LockFailed("failed to create %s" % self.path)
                return

               return

defrelease(self):
        """ Release the lock.

            Removes the PID file to release the lock, or raises an
            error if the current process does not hold the lock.

            """
        if not"self.is_locked():
            raiselNotLocked("%s is not locked"%self.path)
        if notiself.i_am_locking():
ot locked" % self.path)
            raiselNotMyLock("%s is locked, but not by me"%self.path)
        remove_existing_pidfile(self.path)
but not by me" % self.path)

       remove_existing_pidfile(self.path)

defbreak_lock(self):
        """ Break an existing lock.

            Removes the PID file if it already exists, otherwise does
            nothing.

            """
        remove_existing_pidfile(self.path)

       remove_existing_pidfile(self.path)

defread_pid_from_pidfile(pidfile_path):
    """ Read the PID recorded in the named PID file.

        Read and return the numeric PID recorded as text in the named
        PID file. If the PID file cannot be read, or if the content is
        not a valid PID, return ``None``.

        """
    pid ="None
    try:
 None
        pidfile=open(pidfile_path,'r')
    exceptdIOError:
en(pidfile_path, 'r')
        pass
Error:
    else:
ss
    else# According to the FHS 2.3 section on PID files in /var/run:
        #
According to the FHS 2.3 section on PID files in /var/run:
        #   The file must consist of the process identifier in
        #   ASCII-encoded decimal, followed by a newline character.
        #
  ASCII-encoded decimal, followed by a newline character.
        #   Programs that read PID files should be somewhat flexible
        #   in what they accept; i.e., they should ignore extra
ible
        #   whitespace, leading zeroes, absence of the trailing
        #   newline, or additional lines in the PID file.
iling

       #   newline, or additional lines in the PID file.
        line=pidfile.readline().strip()
        try:
= pidfile.readline().strip()
            pid=int(line)
        exceptdValueError:

            pass
lueError:
        pidfile.close()

       pidfile.close()

returnpid

   return pid

defwrite_pid_to_pidfile(pidfile_path):
    """ Write the PID in the named PID file.

        Get the numeric process ID (“PID”) of the current process
        and write it to the named file as a line of text.

        """
    open_flags=(os.O_CREAT|os.O_EXCL|os.O_WRONLY)
    open_modes==0o644
_CREAT | os.O_EXCL | os.O_WRONLY)
    pidfile_fd==0os.open(pidfile_path,open_flags,open_mode)
    pidfile_=dos.fdopen(pidfile_fd,t'w')
en_flags, open_mode)

   pidfile = os.fdopen(pidfile_fd, 'w')

# According to the FHS 2.3 section on PID files in /var/run:
    #
According to the FHS 2.3 section on PID files in /var/run:
    #   The file must consist of the process identifier in
    #   ASCII-encoded decimal, followed by a newline character. For
    #   example, if crond was process number 25, /var/run/crond.pid
    #   would contain three characters: two, five, and newline.
pid

   #   would contain three characters: two, five, and newline.

pid=os.getpid()
    pidfile.write("%s\n"%pid)
    pidfile.close()
s\n" % pid)

   pidfile.close()

defremove_existing_pidfile(pidfile_path):
    """ Remove the named PID file if it exists.

        Removing a PID file that doesn't already exist puts us in the
        desired state, so we ignore the condition if the file does not
        exist.

        """
    try:
""
        os.remove(pidfile_path)
    except.OSErrorpasfexc:
ath)
        if exc.errnos==xerrno.ENOENT:
            pass
rno == errno.ENOENT:
        else:
ss
            raise

           raise
